%{
  -------------------------------------------------------------------------
  1) 产生导频分量的子码
  --- 貌似仍然存在问题
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function   Code = genSubcode_pilot(PRN)

N       = 3607;           % weil码长度

% 子码相位差w
w       = [269,  1448, 1028, 1324, 822,  5,    155,  458,  310,  959,  ...
           1238, 1180, 1288, 334,  885,  1362, 181,  1648, 838,  313,  ...
           750,  225,  1477, 309,  108,  1457, 149,  322,  271,  576,  ...
           1103, 450,  399,  241,  1045, 164,  513,  687,  422,  303,  ...
           324,  495,  725,  780,  367,  882,  631,  37,   647,  1043, ...
           24,   120,  134,  136,  158,  214,  335,  340,  661,  889,  ...
           929,  1002, 1149];
       
% 子码截取点p
p       = [1889, 1268, 1593, 1186, 1239, 1930, 176,  1696, 26,   1344, ...
           1271, 1182, 1381, 1604, 1333, 1185, 31,   704,  1190, 1646, ...
           1385, 113,  860,  1656, 1921, 1173, 1928, 57,   150,  1214, ...
           1148, 1458, 1519, 1635, 1257, 1687, 1382, 1514, 1,    1583, ...
           1806, 1664, 1338, 1111, 1706, 1543, 1813, 228,  2871, 2884, ...
           1823, 75,   11,   63,   1937, 22,   1768, 1526, 1402, 1445, ...
           1680, 1290, 1245];
       
% 生成B1C导频分量的子码
L       = zeros(1,N);

% 计算长度为N的勒让德序列
for k = 1:N
    
   t      = mod((k-1)^2, N); 
   L(t+1) = 1; 
    
end

% 利用勒让德序列生成B1C数据分量主码
Ckwp    = zeros(1,N);
for k = 1:N
   
    Ckwp(k) = xor(L(mod(k-1+p(PRN)-1,N)+1), L(mod(k-1+p(PRN)-1+w(PRN),N)+1));
    
end

% 截断
Code   = Ckwp(1:1800);

return